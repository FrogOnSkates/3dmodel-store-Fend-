{"ast":null,"code":"import { C } from \"./stegaClean.js\";\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path)) throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\") return `${target}[${segment}]`;\n    if (segmentType === \"string\") return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key) return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n    \"\\f\": \"\\\\f\",\n    \"\\n\": \"\\\\n\",\n    \"\\r\": \"\\\\r\",\n    \"\t\": \"\\\\t\",\n    \"'\": \"\\\\'\",\n    \"\\\\\": \"\\\\\\\\\"\n  },\n  UNESCAPE = {\n    \"\\\\f\": \"\\f\",\n    \"\\\\n\": `\n`,\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\t\",\n    \"\\\\'\": \"'\",\n    \"\\\\\\\\\": \"\\\\\"\n  };\nfunction jsonPath(path) {\n  return `$${path.map(segment => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, match => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, match => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [],\n    parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null;) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, m => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, m => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map(segment => {\n    if (typeof segment == \"string\" || typeof segment == \"number\") return segment;\n    if (segment._key !== \"\") return {\n      _key: segment._key\n    };\n    if (segment._index !== -1) return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map(segment => {\n    if (typeof segment == \"string\" || typeof segment == \"number\") return segment;\n    if (segment._index !== -1) return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!csm?.mappings) return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0) return {\n    mapping: csm.mappings[resultMappingPath],\n    matchedPath: resultMappingPath,\n    pathSuffix: \"\"\n  };\n  const mappings = Object.entries(csm.mappings).filter(_ref => {\n    let [key] = _ref;\n    return resultMappingPath.startsWith(key);\n  }).sort((_ref2, _ref3) => {\n    let [key1] = _ref2;\n    let [key2] = _ref3;\n    return key2.length - key1.length;\n  });\n  if (mappings.length == 0) return;\n  const [matchedPath, mapping] = mappings[0],\n    pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return {\n    mapping,\n    matchedPath,\n    pathSuffix\n  };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn) {\n  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return isArray(value) ? value.map((v, idx) => {\n    if (isRecord(v)) {\n      const _key = v._key;\n      if (typeof _key == \"string\") return walkMap(v, mappingFn, path.concat({\n        _key,\n        _index: idx\n      }));\n    }\n    return walkMap(v, mappingFn, path.concat(idx));\n  }) : isRecord(value) ? Object.fromEntries(Object.entries(value).map(_ref4 => {\n    let [k, v] = _ref4;\n    return [k, walkMap(v, mappingFn, path.concat(k))];\n  })) : mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\") return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult) return value;\n    const {\n      mapping,\n      matchedPath\n    } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\") return value;\n    const sourceDocument = csm.documents[mapping.source.document],\n      sourcePath = csm.paths[mapping.source.path],\n      matchPathSegments = parseJsonPath(matchedPath),\n      fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  return id.startsWith(DRAFTS_PREFIX) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl) throw new Error(\"baseUrl is required\");\n  if (!path) throw new Error(\"path is required\");\n  if (!_id) throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace,\n    tool = _tool === \"default\" ? void 0 : _tool,\n    id = getPublishedId(_id),\n    stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path,\n    searchParams = new URLSearchParams({\n      baseUrl,\n      id,\n      type,\n      path: stringifiedPath\n    });\n  workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), _id.startsWith(DRAFTS_PREFIX) && searchParams.set(\"isDraft\", \"\");\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\"mode=presentation\", `id=${id}`, `type=${type}`, `path=${encodeURIComponent(stringifiedPath)}`];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? {\n    baseUrl\n  } : {\n    ...studioUrl,\n    baseUrl\n  };\n}\nconst filterDefault = _ref5 => {\n    let {\n      sourcePath,\n      resultPath,\n      value\n    } = _ref5;\n    if (isValidDate(value) || isValidURL(value)) return !1;\n    const endPath = sourcePath.at(-1);\n    return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && (endPath.startsWith(\"_\") || endPath.endsWith(\"Id\")) || typeof endPath == \"number\" && sourcePath.at(-2) === \"marks\" || endPath === \"href\" && typeof sourcePath.at(-2) == \"number\" && sourcePath.at(-3) === \"markDefs\" || endPath === \"style\" || endPath === \"listItem\" || sourcePath.some(path => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\") || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n  },\n  denylist = /* @__PURE__ */new Set([\"color\", \"colour\", \"currency\", \"email\", \"format\", \"gid\", \"hex\", \"href\", \"hsl\", \"hsla\", \"icon\", \"id\", \"index\", \"key\", \"language\", \"layout\", \"link\", \"linkAction\", \"locale\", \"lqip\", \"page\", \"path\", \"ref\", \"rgb\", \"rgba\", \"route\", \"secret\", \"slug\", \"status\", \"tag\", \"template\", \"theme\", \"type\", \"textTheme\", \"unit\", \"url\", \"username\", \"variant\", \"website\"]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction hasTypeLike(path) {\n  return path.some(segment => typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  const {\n    filter,\n    logger,\n    enabled\n  } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, {\n      result,\n      resultSourceMap,\n      config\n    }), new TypeError(msg);\n  }\n  if (!resultSourceMap) return logger?.error?.(\"[@sanity/client]: Missing Content Source Map from response body\", {\n    result,\n    resultSourceMap,\n    config\n  }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, {\n      result,\n      resultSourceMap,\n      config\n    }), new TypeError(msg);\n  }\n  const report = {\n      encoded: [],\n      skipped: []\n    },\n    resultWithStega = encodeIntoResult(result, resultSourceMap, _ref6 => {\n      let {\n        sourcePath,\n        sourceDocument,\n        resultPath,\n        value\n      } = _ref6;\n      if ((typeof filter == \"function\" ? filter({\n        sourcePath,\n        resultPath,\n        filterDefault,\n        sourceDocument,\n        value\n      }) : filterDefault({\n        sourcePath,\n        resultPath,\n        filterDefault,\n        sourceDocument,\n        value\n      })) === !1) return logger && report.skipped.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const {\n        baseUrl,\n        workspace,\n        tool\n      } = resolveStudioBaseRoute(typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl);\n      if (!baseUrl) return value;\n      const {\n        _id: id,\n        _type: type,\n        _projectId: projectId,\n        _dataset: dataset\n      } = sourceDocument;\n      return C(value, {\n        origin: \"sanity.io\",\n        href: createEditUrl({\n          baseUrl,\n          workspace,\n          tool,\n          id,\n          type,\n          path: sourcePath,\n          ...(!config.omitCrossDatasetReferenceData && {\n            dataset,\n            projectId\n          })\n        })\n      },\n      // We use custom logic to determine if we should skip encoding\n      !1);\n    });\n  if (logger) {\n    const isSkipping = report.skipped.length,\n      isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((logger?.groupCollapsed || logger.log)?.(\"[@sanity/client]: Encoding source map into result\"), logger.log?.(`[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`)), report.encoded.length > 0 && (logger?.log?.(\"[@sanity/client]: Table of encoded paths\"), (logger?.table || logger.log)?.(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */new Set();\n      for (const {\n        path\n      } of report.skipped) skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      logger?.log?.(\"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && logger?.groupEnd?.();\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\nexport { encodeIntoResult, stegaEncodeSourceMap, stegaEncodeSourceMap$1 };\n//# sourceMappingURL=stegaEncodeSourceMap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}