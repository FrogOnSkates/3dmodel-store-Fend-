{"ast":null,"code":"import { g as e } from \"./_chunks-es/_commonjsHelpers.js\";\nimport { p as t, v as s } from \"./_chunks-es/_commonjsHelpers.js\";\nfunction n(e) {\n  return {};\n}\nconst r = /^\\//,\n  o = /\\/$/;\nfunction i(e) {\n  const t = e.replace(o, \"\");\n  return {\n    processOptions: e => {\n      if (/^https?:\\/\\//i.test(e.url)) return e;\n      const s = [t, e.url.replace(r, \"\")].join(\"/\");\n      return Object.assign({}, e, {\n        url: s\n      });\n    }\n  };\n}\nvar a,\n  c,\n  u = {\n    exports: {}\n  };\nfunction l() {\n  if (c) return a;\n  c = 1;\n  var e = 1e3,\n    t = 60 * e,\n    s = 60 * t,\n    n = 24 * s,\n    r = 7 * n,\n    o = 365.25 * n;\n  function i(e, t, s, n) {\n    var r = t >= 1.5 * s;\n    return Math.round(e / s) + \" \" + n + (r ? \"s\" : \"\");\n  }\n  return a = function (a, c) {\n    c = c || {};\n    var u,\n      l,\n      p = typeof a;\n    if (\"string\" === p && a.length > 0) return function (i) {\n      if (!((i = String(i)).length > 100)) {\n        var a = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(i);\n        if (a) {\n          var c = parseFloat(a[1]);\n          switch ((a[2] || \"ms\").toLowerCase()) {\n            case \"years\":\n            case \"year\":\n            case \"yrs\":\n            case \"yr\":\n            case \"y\":\n              return c * o;\n            case \"weeks\":\n            case \"week\":\n            case \"w\":\n              return c * r;\n            case \"days\":\n            case \"day\":\n            case \"d\":\n              return c * n;\n            case \"hours\":\n            case \"hour\":\n            case \"hrs\":\n            case \"hr\":\n            case \"h\":\n              return c * s;\n            case \"minutes\":\n            case \"minute\":\n            case \"mins\":\n            case \"min\":\n            case \"m\":\n              return c * t;\n            case \"seconds\":\n            case \"second\":\n            case \"secs\":\n            case \"sec\":\n            case \"s\":\n              return c * e;\n            case \"milliseconds\":\n            case \"millisecond\":\n            case \"msecs\":\n            case \"msec\":\n            case \"ms\":\n              return c;\n            default:\n              return;\n          }\n        }\n      }\n    }(a);\n    if (\"number\" === p && isFinite(a)) return c.long ? (u = a, (l = Math.abs(u)) >= n ? i(u, l, n, \"day\") : l >= s ? i(u, l, s, \"hour\") : l >= t ? i(u, l, t, \"minute\") : l >= e ? i(u, l, e, \"second\") : u + \" ms\") : function (r) {\n      var o = Math.abs(r);\n      return o >= n ? Math.round(r / n) + \"d\" : o >= s ? Math.round(r / s) + \"h\" : o >= t ? Math.round(r / t) + \"m\" : o >= e ? Math.round(r / e) + \"s\" : r + \"ms\";\n    }(a);\n    throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(a));\n  };\n}\nvar p = function (e) {\n  function t(e) {\n    let n,\n      r,\n      o,\n      i = null;\n    function a(...e) {\n      if (!a.enabled) return;\n      const s = a,\n        r = Number(new Date()),\n        o = r - (n || r);\n      s.diff = o, s.prev = n, s.curr = r, n = r, e[0] = t.coerce(e[0]), \"string\" != typeof e[0] && e.unshift(\"%O\");\n      let i = 0;\n      e[0] = e[0].replace(/%([a-zA-Z%])/g, (n, r) => {\n        if (\"%%\" === n) return \"%\";\n        i++;\n        const o = t.formatters[r];\n        if (\"function\" == typeof o) {\n          const t = e[i];\n          n = o.call(s, t), e.splice(i, 1), i--;\n        }\n        return n;\n      }), t.formatArgs.call(s, e), (s.log || t.log).apply(s, e);\n    }\n    return a.namespace = e, a.useColors = t.useColors(), a.color = t.selectColor(e), a.extend = s, a.destroy = t.destroy, Object.defineProperty(a, \"enabled\", {\n      enumerable: !0,\n      configurable: !1,\n      get: () => null !== i ? i : (r !== t.namespaces && (r = t.namespaces, o = t.enabled(e)), o),\n      set: e => {\n        i = e;\n      }\n    }), \"function\" == typeof t.init && t.init(a), a;\n  }\n  function s(e, s) {\n    const n = t(this.namespace + (typeof s > \"u\" ? \":\" : s) + e);\n    return n.log = this.log, n;\n  }\n  function n(e) {\n    return e.toString().substring(2, e.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n  }\n  return t.debug = t, t.default = t, t.coerce = function (e) {\n    return e instanceof Error ? e.stack || e.message : e;\n  }, t.disable = function () {\n    const e = [...t.names.map(n), ...t.skips.map(n).map(e => \"-\" + e)].join(\",\");\n    return t.enable(\"\"), e;\n  }, t.enable = function (e) {\n    let s;\n    t.save(e), t.namespaces = e, t.names = [], t.skips = [];\n    const n = (\"string\" == typeof e ? e : \"\").split(/[\\s,]+/),\n      r = n.length;\n    for (s = 0; s < r; s++) n[s] && (\"-\" === (e = n[s].replace(/\\*/g, \".*?\"))[0] ? t.skips.push(new RegExp(\"^\" + e.slice(1) + \"$\")) : t.names.push(new RegExp(\"^\" + e + \"$\")));\n  }, t.enabled = function (e) {\n    if (\"*\" === e[e.length - 1]) return !0;\n    let s, n;\n    for (s = 0, n = t.skips.length; s < n; s++) if (t.skips[s].test(e)) return !1;\n    for (s = 0, n = t.names.length; s < n; s++) if (t.names[s].test(e)) return !0;\n    return !1;\n  }, t.humanize = l(), t.destroy = function () {\n    console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n  }, Object.keys(e).forEach(s => {\n    t[s] = e[s];\n  }), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function (e) {\n    let s = 0;\n    for (let t = 0; t < e.length; t++) s = (s << 5) - s + e.charCodeAt(t), s |= 0;\n    return t.colors[Math.abs(s) % t.colors.length];\n  }, t.enable(t.load()), t;\n};\n!function (e, t) {\n  t.formatArgs = function (t) {\n    if (t[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + t[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + e.exports.humanize(this.diff), !this.useColors) return;\n    const s = \"color: \" + this.color;\n    t.splice(1, 0, s, \"color: inherit\");\n    let n = 0,\n      r = 0;\n    t[0].replace(/%[a-zA-Z%]/g, e => {\n      \"%%\" !== e && (n++, \"%c\" === e && (r = n));\n    }), t.splice(r, 0, s);\n  }, t.save = function (e) {\n    try {\n      e ? t.storage.setItem(\"debug\", e) : t.storage.removeItem(\"debug\");\n    } catch {}\n  }, t.load = function () {\n    let e;\n    try {\n      e = t.storage.getItem(\"debug\");\n    } catch {}\n    return !e && typeof process < \"u\" && \"env\" in process && (e = process.env.DEBUG), e;\n  }, t.useColors = function () {\n    return !(!(typeof window < \"u\" && window.process) || \"renderer\" !== window.process.type && !window.process.__nwjs) || !(typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) && (typeof document < \"u\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < \"u\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n  }, t.storage = function () {\n    try {\n      return localStorage;\n    } catch {}\n  }(), t.destroy = (() => {\n    let e = !1;\n    return () => {\n      e || (e = !0, console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"));\n    };\n  })(), t.colors = [\"#0000CC\", \"#0000FF\", \"#0033CC\", \"#0033FF\", \"#0066CC\", \"#0066FF\", \"#0099CC\", \"#0099FF\", \"#00CC00\", \"#00CC33\", \"#00CC66\", \"#00CC99\", \"#00CCCC\", \"#00CCFF\", \"#3300CC\", \"#3300FF\", \"#3333CC\", \"#3333FF\", \"#3366CC\", \"#3366FF\", \"#3399CC\", \"#3399FF\", \"#33CC00\", \"#33CC33\", \"#33CC66\", \"#33CC99\", \"#33CCCC\", \"#33CCFF\", \"#6600CC\", \"#6600FF\", \"#6633CC\", \"#6633FF\", \"#66CC00\", \"#66CC33\", \"#9900CC\", \"#9900FF\", \"#9933CC\", \"#9933FF\", \"#99CC00\", \"#99CC33\", \"#CC0000\", \"#CC0033\", \"#CC0066\", \"#CC0099\", \"#CC00CC\", \"#CC00FF\", \"#CC3300\", \"#CC3333\", \"#CC3366\", \"#CC3399\", \"#CC33CC\", \"#CC33FF\", \"#CC6600\", \"#CC6633\", \"#CC9900\", \"#CC9933\", \"#CCCC00\", \"#CCCC33\", \"#FF0000\", \"#FF0033\", \"#FF0066\", \"#FF0099\", \"#FF00CC\", \"#FF00FF\", \"#FF3300\", \"#FF3333\", \"#FF3366\", \"#FF3399\", \"#FF33CC\", \"#FF33FF\", \"#FF6600\", \"#FF6633\", \"#FF9900\", \"#FF9933\", \"#FFCC00\", \"#FFCC33\"], t.log = console.debug || console.log || (() => {}), e.exports = p(t);\n  const {\n    formatters: s\n  } = e.exports;\n  s.j = function (e) {\n    try {\n      return JSON.stringify(e);\n    } catch (e) {\n      return \"[UnexpectedJSONParseError]: \" + e.message;\n    }\n  };\n}(u, u.exports);\nvar d = e(u.exports);\nconst f = [\"cookie\", \"authorization\"],\n  m = Object.prototype.hasOwnProperty;\nfunction C(e = {}) {\n  const t = e.verbose,\n    s = e.namespace || \"get-it\",\n    n = d(s),\n    r = e.log || n,\n    o = r === n && !d.enabled(s);\n  let i = 0;\n  return {\n    processOptions: e => (e.debug = r, e.requestId = e.requestId || ++i, e),\n    onRequest: s => {\n      if (o || !s) return s;\n      const n = s.options;\n      if (r(\"[%s] HTTP %s %s\", n.requestId, n.method, n.url), t && n.body && \"string\" == typeof n.body && r(\"[%s] Request body: %s\", n.requestId, n.body), t && n.headers) {\n        const t = !1 === e.redactSensitiveHeaders ? n.headers : ((e, t) => {\n          const s = {};\n          for (const n in e) m.call(e, n) && (s[n] = t.indexOf(n.toLowerCase()) > -1 ? \"<redacted>\" : e[n]);\n          return s;\n        })(n.headers, f);\n        r(\"[%s] Request headers: %s\", n.requestId, JSON.stringify(t, null, 2));\n      }\n      return s;\n    },\n    onResponse: (e, s) => {\n      if (o || !e) return e;\n      const n = s.options.requestId;\n      return r(\"[%s] Response code: %s %s\", n, e.statusCode, e.statusMessage), t && e.body && r(\"[%s] Response body: %s\", n, function (e) {\n        return -1 !== (e.headers[\"content-type\"] || \"\").toLowerCase().indexOf(\"application/json\") ? function (e) {\n          try {\n            const t = \"string\" == typeof e ? JSON.parse(e) : e;\n            return JSON.stringify(t, null, 2);\n          } catch {\n            return e;\n          }\n        }(e.body) : e.body;\n      }(e)), e;\n    },\n    onError: (e, t) => {\n      const s = t.options.requestId;\n      return e ? (r(\"[%s] ERROR: %s\", s, e.message), e) : (r(\"[%s] Error encountered, but handled by an earlier middleware\", s), e);\n    }\n  };\n}\nfunction h(e, t = {}) {\n  return {\n    processOptions: s => {\n      const n = s.headers || {};\n      return s.headers = t.override ? Object.assign({}, n, e) : Object.assign({}, e, n), s;\n    }\n  };\n}\nclass g extends Error {\n  response;\n  request;\n  constructor(e, t) {\n    super();\n    const s = e.url.length > 400 ? `${e.url.slice(0, 399)}…` : e.url;\n    let n = `${e.method}-request to ${s} resulted in `;\n    n += `HTTP ${e.statusCode} ${e.statusMessage}`, this.message = n.trim(), this.response = e, this.request = t.options;\n  }\n}\nfunction b() {\n  return {\n    onResponse: (e, t) => {\n      if (!(e.statusCode >= 400)) return e;\n      throw new g(e, t);\n    }\n  };\n}\nfunction y(e = {}) {\n  if (\"function\" != typeof e.inject) throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n  return {\n    interceptRequest: function (t, s) {\n      const n = e.inject(s, t);\n      if (!n) return t;\n      const r = s.context.options;\n      return {\n        body: \"\",\n        url: r.url,\n        method: r.method,\n        headers: {},\n        statusCode: 200,\n        statusMessage: \"OK\",\n        ...n\n      };\n    }\n  };\n}\nconst w = typeof Buffer > \"u\" ? () => !1 : e => Buffer.isBuffer(e);\nfunction F(e) {\n  return \"[object Object]\" === Object.prototype.toString.call(e);\n}\nfunction O(e) {\n  if (!1 === F(e)) return !1;\n  const t = e.constructor;\n  if (void 0 === t) return !0;\n  const s = t.prototype;\n  return !(!1 === F(s) || !1 === s.hasOwnProperty(\"isPrototypeOf\"));\n}\nconst j = [\"boolean\", \"string\", \"number\"];\nfunction v() {\n  return {\n    processOptions: e => {\n      const t = e.body;\n      return !t || \"function\" == typeof t.pipe || w(t) || -1 === j.indexOf(typeof t) && !Array.isArray(t) && !O(t) ? e : Object.assign({}, e, {\n        body: JSON.stringify(e.body),\n        headers: Object.assign({}, e.headers, {\n          \"Content-Type\": \"application/json\"\n        })\n      });\n    }\n  };\n}\nfunction x(e) {\n  return {\n    onResponse: s => {\n      const n = s.headers[\"content-type\"] || \"\",\n        r = e && e.force || -1 !== n.indexOf(\"application/json\");\n      return s.body && n && r ? Object.assign({}, s, {\n        body: t(s.body)\n      }) : s;\n    },\n    processOptions: e => Object.assign({}, e, {\n      headers: Object.assign({\n        Accept: \"application/json\"\n      }, e.headers)\n    })\n  };\n  function t(e) {\n    try {\n      return JSON.parse(e);\n    } catch (e) {\n      throw e.message = `Failed to parsed response body as JSON: ${e.message}`, e;\n    }\n  }\n}\nfunction E(e = {}) {\n  if (!e.ca) throw new Error('Required mtls option \"ca\" is missing');\n  if (!e.cert) throw new Error('Required mtls option \"cert\" is missing');\n  if (!e.key) throw new Error('Required mtls option \"key\" is missing');\n  return {\n    finalizeOptions: t => {\n      if (function (e) {\n        return \"object\" == typeof e && null !== e && !(\"protocol\" in e);\n      }(t)) return t;\n      const s = {\n        cert: e.cert,\n        key: e.key,\n        ca: e.ca\n      };\n      return Object.assign({}, t, s);\n    }\n  };\n}\nlet R = {};\ntypeof globalThis < \"u\" ? R = globalThis : typeof window < \"u\" ? R = window : typeof global < \"u\" ? R = global : typeof self < \"u\" && (R = self);\nvar k = R;\nfunction q(e = {}) {\n  const t = e.implementation || k.Observable;\n  if (!t) throw new Error(\"`Observable` is not available in global scope, and no implementation was passed\");\n  return {\n    onReturn: (e, s) => new t(t => (e.error.subscribe(e => t.error(e)), e.progress.subscribe(e => t.next(Object.assign({\n      type: \"progress\"\n    }, e))), e.response.subscribe(e => {\n      t.next(Object.assign({\n        type: \"response\"\n      }, e)), t.complete();\n    }), e.request.publish(s), () => e.abort.publish()))\n  };\n}\nfunction A() {\n  return {\n    onRequest: e => {\n      if (\"xhr\" !== e.adapter) return;\n      const t = e.request,\n        s = e.context;\n      function n(e) {\n        return t => {\n          const n = t.lengthComputable ? t.loaded / t.total * 100 : -1;\n          s.channels.progress.publish({\n            stage: e,\n            percent: n,\n            total: t.total,\n            loaded: t.loaded,\n            lengthComputable: t.lengthComputable\n          });\n        };\n      }\n      \"upload\" in t && \"onprogress\" in t.upload && (t.upload.onprogress = n(\"upload\")), \"onprogress\" in t && (t.onprogress = n(\"download\"));\n    }\n  };\n}\nconst S = (e = {}) => {\n  const t = e.implementation || Promise;\n  if (!t) throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n  return {\n    onReturn: (s, n) => new t((t, r) => {\n      const o = n.options.cancelToken;\n      o && o.promise.then(e => {\n        s.abort.publish(e), r(e);\n      }), s.error.subscribe(r), s.response.subscribe(s => {\n        t(e.onlyBody ? s.body : s);\n      }), setTimeout(() => {\n        try {\n          s.request.publish(n);\n        } catch (e) {\n          r(e);\n        }\n      }, 0);\n    })\n  };\n};\nclass N {\n  __CANCEL__ = !0;\n  message;\n  constructor(e) {\n    this.message = e;\n  }\n  toString() {\n    return \"Cancel\" + (this.message ? `: ${this.message}` : \"\");\n  }\n}\nclass $ {\n  promise;\n  reason;\n  constructor(e) {\n    if (\"function\" != typeof e) throw new TypeError(\"executor must be a function.\");\n    let t = null;\n    this.promise = new Promise(e => {\n      t = e;\n    }), e(e => {\n      this.reason || (this.reason = new N(e), t(this.reason));\n    });\n  }\n  static source = () => {\n    let e;\n    return {\n      token: new $(t => {\n        e = t;\n      }),\n      cancel: e\n    };\n  };\n}\nfunction T(e) {\n  if (!(!1 === e || e && e.host)) throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n  return {\n    processOptions: t => Object.assign({\n      proxy: e\n    }, t)\n  };\n}\nS.Cancel = N, S.CancelToken = $, S.isCancel = e => !(!e || !e?.__CANCEL__);\nvar I = (e, t, s) => (\"GET\" === s.method || \"HEAD\" === s.method) && (e.isNetworkError || !1);\nfunction M(e) {\n  return 100 * Math.pow(2, e) + 100 * Math.random();\n}\nconst _ = (e = {}) => (e => {\n  const t = e.maxRetries || 5,\n    s = e.retryDelay || M,\n    n = e.shouldRetry;\n  return {\n    onError: (e, r) => {\n      const o = r.options,\n        i = o.maxRetries || t,\n        a = o.retryDelay || s,\n        c = o.shouldRetry || n,\n        u = o.attemptNumber || 0;\n      if (null !== (l = o.body) && \"object\" == typeof l && \"function\" == typeof l.pipe || !c(e, u, o) || u >= i) return e;\n      var l;\n      const p = Object.assign({}, r, {\n        options: Object.assign({}, o, {\n          attemptNumber: u + 1\n        })\n      });\n      return setTimeout(() => r.channels.request.publish(p), a(u)), null;\n    }\n  };\n})({\n  shouldRetry: I,\n  ...e\n});\nfunction P(e) {\n  const t = new URLSearchParams(),\n    s = (e, n) => {\n      const r = n instanceof Set ? Array.from(n) : n;\n      if (Array.isArray(r)) {\n        if (r.length) for (const t in r) s(`${e}[${t}]`, r[t]);else t.append(`${e}[]`, \"\");\n      } else if (\"object\" == typeof r && null !== r) for (const [t, n] of Object.entries(r)) s(`${e}[${t}]`, n);else t.append(e, r);\n    };\n  for (const [t, n] of Object.entries(e)) s(t, n);\n  return t.toString();\n}\nfunction J() {\n  return {\n    processOptions: e => {\n      const t = e.body;\n      return t && \"function\" != typeof t.pipe && !w(t) && O(t) ? {\n        ...e,\n        body: P(e.body),\n        headers: {\n          ...e.headers,\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n      } : e;\n    }\n  };\n}\n_.shouldRetry = I;\nclass L extends Error {\n  request;\n  code;\n  constructor(e, t) {\n    super(e.message), this.request = t, this.code = e.code;\n  }\n}\nconst z = (H = n, function (e = {}) {\n  const {\n      maxRetries: t = 3,\n      ms: s = 1e3,\n      maxFree: n = 256\n    } = e,\n    {\n      finalizeOptions: r\n    } = H({\n      keepAlive: !0,\n      keepAliveMsecs: s,\n      maxFreeSockets: n\n    });\n  return {\n    finalizeOptions: r,\n    onError: (e, s) => {\n      if ((\"GET\" === s.options.method || \"POST\" === s.options.method) && e instanceof L && \"ECONNRESET\" === e.code && e.request.reusedSocket) {\n        const e = s.options.attemptNumber || 0;\n        if (e < t) {\n          const t = Object.assign({}, s, {\n            options: Object.assign({}, s.options, {\n              attemptNumber: e + 1\n            })\n          });\n          return setImmediate(() => s.channels.request.publish(t)), null;\n        }\n      }\n      return e;\n    }\n  };\n});\nvar H;\nexport { N as Cancel, $ as CancelToken, n as agent, i as base, C as debug, h as headers, b as httpErrors, y as injectResponse, v as jsonRequest, x as jsonResponse, z as keepAlive, E as mtls, q as observable, t as processOptions, A as progress, S as promise, T as proxy, _ as retry, J as urlEncoded, s as validateOptions }; //# sourceMappingURL=middleware.browser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}