{"ast":null,"code":"import { p as e, v as t, g as r } from \"./_chunks-es/_commonjsHelpers.js\";\nconst o = [\"request\", \"response\", \"progress\", \"error\", \"abort\"],\n  s = [\"processOptions\", \"validateOptions\", \"interceptRequest\", \"finalizeOptions\", \"onRequest\", \"onResponse\", \"onError\", \"onReturn\", \"onHeaders\"];\nfunction n(r, a) {\n  const i = [],\n    u = s.reduce((e, t) => (e[t] = e[t] || [], e), {\n      processOptions: [e],\n      validateOptions: [t]\n    });\n  function l(e) {\n    const t = o.reduce((e, t) => (e[t] = function () {\n        const e = Object.create(null);\n        let t = 0;\n        return {\n          publish: function (t) {\n            for (const r in e) e[r](t);\n          },\n          subscribe: function (r) {\n            const o = t++;\n            return e[o] = r, function () {\n              delete e[o];\n            };\n          }\n        };\n      }(), e), {}),\n      r = (e => function (t, r) {\n        const s = \"onError\" === t;\n        let n = r;\n        for (var _len = arguments.length, o = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          o[_key - 2] = arguments[_key];\n        }\n        for (let r = 0; r < e[t].length && (n = (0, e[t][r])(n, ...o), !s || n); r++);\n        return n;\n      })(u),\n      s = r(\"processOptions\", e);\n    r(\"validateOptions\", s);\n    const n = {\n      options: s,\n      channels: t,\n      applyMiddleware: r\n    };\n    let i;\n    const l = t.request.subscribe(e => {\n      i = a(e, (o, s) => ((e, o, s) => {\n        let n = e,\n          a = o;\n        if (!n) try {\n          a = r(\"onResponse\", o, s);\n        } catch (e) {\n          a = null, n = e;\n        }\n        n = n && r(\"onError\", n, s), n ? t.error.publish(n) : a && t.response.publish(a);\n      })(o, s, e));\n    });\n    t.abort.subscribe(() => {\n      l(), i && i.abort();\n    });\n    const c = r(\"onReturn\", t, n);\n    return c === t && t.request.publish(n), c;\n  }\n  return l.use = function (e) {\n    if (!e) throw new Error(\"Tried to add middleware that resolved to falsey value\");\n    if (\"function\" == typeof e) throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n    if (e.onReturn && u.onReturn.length > 0) throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n    return s.forEach(t => {\n      e[t] && u[t].push(e[t]);\n    }), i.push(e), l;\n  }, l.clone = () => n(i, a), r.forEach(l.use), l;\n}\nvar a = function (e) {\n    return e.replace(/^\\s+|\\s+$/g, \"\");\n  },\n  i = r(function (e) {\n    if (!e) return {};\n    for (var t = {}, r = a(e).split(\"\\n\"), o = 0; o < r.length; o++) {\n      var s = r[o],\n        n = s.indexOf(\":\"),\n        i = a(s.slice(0, n)).toLowerCase(),\n        u = a(s.slice(n + 1));\n      typeof t[i] > \"u\" ? t[i] = u : (l = t[i], \"[object Array]\" === Object.prototype.toString.call(l) ? t[i].push(u) : t[i] = [t[i], u]);\n    }\n    var l;\n    return t;\n  });\nclass u {\n  onabort;\n  onerror;\n  onreadystatechange;\n  ontimeout;\n  readyState = 0;\n  response;\n  responseText = \"\";\n  responseType = \"\";\n  status;\n  statusText;\n  withCredentials;\n  #e;\n  #t;\n  #r;\n  #o = {};\n  #s;\n  #n = {};\n  #a;\n  open(e, t, r) {\n    this.#e = e, this.#t = t, this.#r = \"\", this.readyState = 1, this.onreadystatechange?.(), this.#s = void 0;\n  }\n  abort() {\n    this.#s && this.#s.abort();\n  }\n  getAllResponseHeaders() {\n    return this.#r;\n  }\n  setRequestHeader(e, t) {\n    this.#o[e] = t;\n  }\n  setInit(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n    this.#n = e, this.#a = t;\n  }\n  send(e) {\n    const t = \"arraybuffer\" !== this.responseType,\n      r = {\n        ...this.#n,\n        method: this.#e,\n        headers: this.#o,\n        body: e\n      };\n    \"function\" == typeof AbortController && this.#a && (this.#s = new AbortController(), typeof EventTarget < \"u\" && this.#s.signal instanceof EventTarget && (r.signal = this.#s.signal)), typeof document < \"u\" && (r.credentials = this.withCredentials ? \"include\" : \"omit\"), fetch(this.#t, r).then(e => (e.headers.forEach((e, t) => {\n      this.#r += `${t}: ${e}\\r\\n`;\n    }), this.status = e.status, this.statusText = e.statusText, this.readyState = 3, this.onreadystatechange?.(), t ? e.text() : e.arrayBuffer())).then(e => {\n      \"string\" == typeof e ? this.responseText = e : this.response = e, this.readyState = 4, this.onreadystatechange?.();\n    }).catch(e => {\n      \"AbortError\" !== e.name ? this.onerror?.(e) : this.onabort?.();\n    });\n  }\n}\nconst l = \"function\" == typeof XMLHttpRequest ? \"xhr\" : \"fetch\",\n  c = \"xhr\" === l ? XMLHttpRequest : u,\n  h = (e, t) => {\n    const r = e.options,\n      o = e.applyMiddleware(\"finalizeOptions\", r),\n      s = {},\n      n = e.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter: l,\n        context: e\n      });\n    if (n) {\n      const e = setTimeout(t, 0, null, n);\n      return {\n        abort: () => clearTimeout(e)\n      };\n    }\n    let a = new c();\n    a instanceof u && \"object\" == typeof o.fetch && a.setInit(o.fetch, o.useAbortSignal ?? !0);\n    const h = o.headers,\n      d = o.timeout;\n    let p = !1,\n      f = !1,\n      b = !1;\n    if (a.onerror = e => {\n      m(a instanceof u ? e instanceof Error ? e : new Error(`Request error while attempting to reach is ${o.url}`, {\n        cause: e\n      }) : new Error(`Request error while attempting to reach is ${o.url}${e.lengthComputable ? `(${e.loaded} of ${e.total} bytes transferred)` : \"\"}`));\n    }, a.ontimeout = e => {\n      m(new Error(`Request timeout while attempting to reach ${o.url}${e.lengthComputable ? `(${e.loaded} of ${e.total} bytes transferred)` : \"\"}`));\n    }, a.onabort = () => {\n      w(!0), p = !0;\n    }, a.onreadystatechange = () => {\n      d && (w(), s.socket = setTimeout(() => y(\"ESOCKETTIMEDOUT\"), d.socket)), !p && 4 === a.readyState && 0 !== a.status && function () {\n        if (!(p || f || b)) {\n          if (0 === a.status) return void m(new Error(\"Unknown XHR error\"));\n          w(), f = !0, t(null, {\n            body: a.response || (\"\" === a.responseType || \"text\" === a.responseType ? a.responseText : \"\"),\n            url: o.url,\n            method: o.method,\n            headers: i(a.getAllResponseHeaders()),\n            statusCode: a.status,\n            statusMessage: a.statusText\n          });\n        }\n      }();\n    }, a.open(o.method, o.url, !0), a.withCredentials = !!o.withCredentials, h && a.setRequestHeader) for (const e in h) h.hasOwnProperty(e) && a.setRequestHeader(e, h[e]);\n    return o.rawBody && (a.responseType = \"arraybuffer\"), e.applyMiddleware(\"onRequest\", {\n      options: o,\n      adapter: l,\n      request: a,\n      context: e\n    }), a.send(o.body || null), d && (s.connect = setTimeout(() => y(\"ETIMEDOUT\"), d.connect)), {\n      abort: function () {\n        p = !0, a && a.abort();\n      }\n    };\n    function y(t) {\n      b = !0, a.abort();\n      const r = new Error(\"ESOCKETTIMEDOUT\" === t ? `Socket timed out on request to ${o.url}` : `Connection timed out on request to ${o.url}`);\n      r.code = t, e.channels.error.publish(r);\n    }\n    function w(e) {\n      (e || p || a.readyState >= 2 && s.connect) && clearTimeout(s.connect), s.socket && clearTimeout(s.socket);\n    }\n    function m(e) {\n      if (f) return;\n      w(!0), f = !0, a = null;\n      const r = e || new Error(`Network error while attempting to reach ${o.url}`);\n      r.isNetworkError = !0, r.request = o, t(r);\n    }\n  },\n  d = function () {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : h;\n    return n(e, t);\n  },\n  p = \"browser\";\nexport { l as adapter, p as environment, d as getIt }; //# sourceMappingURL=index.browser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}